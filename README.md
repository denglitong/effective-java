# Effective Java

Java 支持 4 种类型：接口、类（包括 enum）、数组和基本类型。

把焦点放在 API 设计上，对于重构过程是多么有益。重构的基本目标是改进系统结构，以避免代码重复。  
如果系统的组件没有设计良好的 API，要达到这样的目标则是不可能的。

清晰性和简洁性最为重要：组件的用户永远也不应该被其行为所迷惑。  
代码应该被重用，而不是被拷贝。  
组件之间的依赖尽可能降到最小。  
错误应该尽早被检测出来。  
编写出清晰、正确、可用、健壮、灵活和可维护的程序。  

## 2.创建和销毁对象

1. 用静态工厂方法代替构造器
   - 优势
      1. 静态工厂方法它们有名称，可以更具语义
      2. 不必在每次调用它们的时候都创建一个新对象
      3. 它们可以返回原类型的任何子类型的对象
      4. 所返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值
      5. 方法返回对象所属的类，在编写包含该静态工厂方法时可以不存在（服务提供者框架）
   - 缺点
      1. 如果类不含公有的/受保护的构造器，就不能被子类化
      2. 程序员很难发现那些静态工厂方法
   - 静态工厂惯用名称
      1. from, of, valueOf, instance, getInstance, create, newInstance
      2. getType, newTYpe, type
2. 遇到多个构造器参数时考虑使用构建器（Builder）
   - 优势
      1. Builder 模式模拟了具名的可选参数，易于编写和阅读
      2. Builder 模式也适用于类层次结构
   - 缺点
      1. 为了创建对象，必须先创建它的构建器，可能有性能问题
3. 用私有构造器或枚举类型强化 Singleton 属性
   - 私有构造器 + 导出公有静态成员
   - 私有构造器 + 导出公有静态工厂方法（静态工厂方法的优势在于提供了灵活性）
   - 单元素的枚举类型
4. 通过私有构造器强化不可实例化的能力  
   - 企图通过将类做成抽象类来强制该类不可被实例化是行不通的
   - 让这个类包含一个私有构造器，它就不能被实例化（比如工具类就不希望被实例化，它只有静态方法和静态域）
5. 优先考虑依赖注入来引用资源
   - 静态工具类和 Singleton 类不适合与需要引用底层资源的类（资源可能有多种）
   - 当创建一个新的实例时，就将该资源传到构造器中
   - 可使用依赖注入框架（如 Spring）来解决手动注入的凌乱
6. 避免创建不必要的对象  
   - 自动装箱使得基本类型和装箱基本类型之间的差别变得模糊起来，但是并没有完全消失
   - 要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱
   - 通过维护自己的对象池来避免创建对象并不是一种好的做法，除非对象池中的对象是非常重量级的
   - 因重用对象而付出的代价要远远大于因创建重复对象而付出的代价，前者会导致潜在的 Bug 和安全漏洞，后者只会影响程序风格和性能
7. 消除过期的对象引用
   - 无意识的对象保持，在支持垃圾回收语言中是很隐蔽的内存泄漏
   - 清空对象引用应该是一种例外，而不是一种规范行为
   - 只要类是自己管理内存，程序员就应该警惕内存泄漏问题
   - 内存泄漏的另一个场景来源是缓存
   - 内存泄漏的第三个常见来源是监听器和其他回调
   - 可借助 Heap Profiler 发现内存泄漏问题
8. 避免使用终结方法和清除方法
   - 终结方法（finalizer）通常是不可预测的，也是危险的，一般情况下是不必要的
   - 在 Java9 中庸清除方法（cleaner）代替了 finalizer，清除方法没有终结方法那么危险，但仍然是不可预测、运行缓慢，一般情况下也是不必要的
   - 终结方法和清除方法的缺点在于不能保证会被及时执行，Java规范根本不保证它们会被执行
   - 注重时间的任务不应该由终结方法或者清除方法来完成
   - 永远不应该依赖终结方法或清除方法来更新重要的持久状态
   - 使用终结方法和清除方法有一个非常严重的性能损失
   - 为了防止非 final 类受到终结方法攻击，要编写一个空的 final 的 finalize 方法
   - 终结方法和清除方法的好处有：1.当资源所有者忘记调用它的 close 方法时，终结方法或清除方法可充当"安全网"；2.与对象的本地对等体（native peer）有关，可用来清除非关键的本地方法所拥有的资源
9. try-with-resources 优先于 try-finally
   - try-with-resources 更简洁易懂，也更容易诊断

## 3.对于所有对象都通用的方法    

10. 覆盖 equals 时请遵循通用约定
   - 自反性：x.equals(x) == true，对称性：x.equals(y) == y.equals(x)，传递性，
   - 使用 == 检查参数是否为这个对象的引用；使用 instanceof 检查参数是否为正确的类型；把参数转换为正确的类型；对于该类中的每个关键域检查是否相匹配
   - 覆盖 equals 时总是要覆盖 hashCode；不要企图让 equals 方法过于智能；不要将 equals 声明中的 Object 对象替换为为他类型
11. 覆盖 equals 时总是要覆盖 hashCode
   - 相等的对象必须具有相等的散列码（hash code）
   - 不要试图从散列码计算中排除掉一个对象的关键域来提高性能
   - 不要对 hashCode 方法的返回值做出具体的规定，因此客户端无法理所当然的依赖它；这样可以为修改提供灵活性
12. 始终要覆盖 toString
   - 提供好的 toString 实现可以让类使用起来更加舒适、更易于调试
   - toString 方法应该返回对象中包含的所有值得关注的信息
   - 无论是否决定指定格式，都应该在文档中明确地表明你的意图
   - 为 toString 返回值中包含的信息提供一种可通过编程访问的途径（getter）
13. 谨慎地覆盖 clone
   - 实现 Cloneable 接口的类是为了提供一个功能适当的公有 clone 方法
   - 不可变的类永远都不应该提供 clone 方法
   - clone 方法就是另一个构造器；必须确保它不会伤害到原始的对象，并确保正确地创建被克隆对象中的约束条件
   - Cloneable 架构与引用可变对象的 final 域的正常用法是不相兼容的
   - 公有的 clone 方法应该省略 throws 声明（不抛出受检查一次的方法使用起来更轻松）
   - 对象拷贝的更好的办法是提供一个拷贝构造器或拷贝工厂
14. 考虑实现 Comparable 接口
   - Java 平台类库中的所有值类型和枚举类型都实现了 Comparable 接口
   - Comparable 接口也需要遵守等同性、自反性、对称性和传递性
   - Comparator<T> 可配置一组比较器构造方法，使得比较器的构造工作变得非常流畅
   - 避免使用 Comparator.compare() 方法，可能会造成整数溢出，可使用一个静态的 compare() 方法货真使用一个比较器的构造方法

## 4.类和接口

15. 使类和成员的可访问性最小化
    - 尽可能地使每个类或成员不被外界访问
    - private / package-private / protected / public
    - 公有类的实例域绝不能是公有的，包含公有可变域的类通常并不是线程安全的
    - 让类具有公有的静态 final 数组域，或者提供这种域的访问方法，这是错误的，因为客户端能够改变数组的内容，造成安全漏洞
16. 要在公有类而非公有域（静态域）中使用访问方法
    - 如果类可以在它所在的包之外进行访问，就提供访问方法
    - 如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误
17. 使可变性最小化
    - 不可变对象比较简单
    - 不可变对象本质上是线程安全的，它们不要求同步，可以被自由地共享
    - 不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象
    - 如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性
    - 构造器应该创建完全初始化的对象，并建立起所有的约束条件
18. 组合优先于继承
    - 与方法调用不同的是，继承打破了封装性
    - 只有子类和超类确实存在子类型关系时，且它们处在相同的包中，使用继承才是恰当的
19. 要么设计继承并提供文档说明，要么禁止继承
    - 该类必须有文档必须精确地描述覆盖每个方法所带来的影响
    - 类必须以精心挑选的受保护的（protected）方法的形式，提供恰当的钩子（hook），以便进入其内部工作
    - 对于为了继承而设计的类，唯一的测试方法就是编写子类，必须在发布之前编写子类对其进行测试
    - 为了允许继承，构造器决不能调用可被覆盖的方法（初始化子类时超类构造器中会调用到子类的覆盖方法，该方法可能依赖子类的构造器的初始化，可能出现非预期的状态）
    - 无论是 clone 和 readObject，都不可用调用可覆盖的方法，不管是以直接或间接的方式（clone/readObject 在行为上类似构造器）
    - 为了继承而设计的类，会有一些实质性的限制
    - 对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化
20. 接口由于抽象类
    - 现有的类可以很容易被更新，以实现新的接口
    - 接口是定义混合类型（mixin）的理想选择
    - 接口允许构造非层次结构的类型框架
    - 接口使得安全地增强类的功能称为可能
    - 对于骨架实现类而言，好的文档绝对是非常必要的

21. 为后代设计接口
    - 有了缺省方法，接口的现有实现不会出现编译时没有报错或警告却在运行时失败的情况
    - 谨慎设计接口仍然是至关重要的
    - 或许接口程序发布之后也能纠正，但是千万别指望它！
    
22. 接口只用于定义类型
    - 常量接口模式是对接口的不良使用
    - 导出常量可考虑合理的类（如 Integer.MIN_VALUE）和枚举类型
    
23. 类层次优于标签类
    - 标签类（如包含枚举类型来区别类类型）过于冗长、容易出错，并且效率低下
    - 标签类正是对类层次的一种简单的仿效
    - 标签类很少有适用场景，应转换到类层次结构中去
    
24. 静态成员类优于非静态成员类
    - 如果声明成员类不要求访问外围实例，就要始终把修饰符 static 放在它的声明中

25. 限制源文件为单个顶级类
    - 永远不要把多个顶级类或接口定义在一个源文件中

## 5.泛型

26. 请不要使用原生态类型
    - 原生态类型是指泛型中未声明泛型参数
    - 如果使用原生态类型，就失去了泛型在安全性和描述性方面的所有优势
    - 如果使用像 List 这样的原生态类型，就会失去类型安全性，但是如果使用像 List<Object> 则不会
    - 不能将任何元素（除 null 之外）放到 Collection<?> 中，否则会编译出错类型不匹配
    
27. 消除非受检的警告（unchecking warning）
    - 要尽可能地消除每一个非受检警告
    - 如果无法消除警告，同时可以证明引起警告的代码是类型安全的，此时可以用 @SuppressWarnings("unchecked") 注解来禁止这条警告
    - 应该始终在尽可能小的范围内使用 SuppressWarnings 警告
    
28. 列表由于数组
    - 数组提供了运行时的类型安全，但是没有编译时的类型安全
    
29. 优先考虑泛型
    - 你不能创建不可具体化的类型的数组，如 <T> new T[]，但可以先创建 new Object[] 然后再进行数组类型转换，隐含前提是你需要保证类型安全并消除警告
    
30. 优先考虑泛型方法

31. 利用有限制通配符来提升 API 的灵活性
    - 为了获得最大限度的灵活性，要在表示生产者或消费者的输入参数上使用通配符类型
    - 如果某个输入参数既是生产者，又是消费者，那么通配符就没有好处了：因为你需要的是严格的类型匹配
    - PECS: producer-extends, consumer-super
    - 不要用通配符类型作为返回类型
    - 如果类的用户必须考虑通配符类型，类的 API 或许就会出错
    - 使用时始终应该是 Comparable<? super T> 优先于 Comparable<T>，Comparator<? super T> 同理
    - 如果类型参数只在方法声明中出现一次，就可以用通配符取代它

32. 谨慎同时使用泛型+可变参数
    - 将值保存在泛型可变参数数组中是不安全的
    - SafeVarargs 注解是通过方法的设计者做出承诺，声明这是类型安全的
    - 允许另一个方法访问一个泛型可变参数是不安全的，可变参数在实际的参数存入之后没有修改
    - 对于每一个带有泛型可变参数或者参数化类型的方法，都要用 @SafeVarargs 进行注解
    
33. 优先考虑类型安全的异构容器
    - 异构的：不像普通的映射，容器的所有键都是不同类型的
    - 可以使用 Class 对象作为键，以这种方式使用的 Class 对象称作类型令牌

## 6. 枚举和注解

34. 用 enum 代替 int 常量
    - 为了将数据与枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存在域中的构造器
    - 枚举中的 switch 语句适合于给外部的枚举类型增加特定于常量的行为
    - 每当需要一组固定数量，并且在编译时就知道其成员的时候，就应该使用枚举
    - 枚举类型中的常量集并不一定要始终保持不变

35. 用实例域代替枚举的序数
    - 永远不要根据枚举的序数导出与它关联的值，而是要保存在一个实例域中

36. 用 EnumSet 代替位域
    - 如果一个枚举类型的元素主要用在集合中，一般使用 int 枚举模式（1<<0,1<<1,1<<2,1<<3），通过 OR 运算符将几个常量合并到一个集合中去，称作位域
    - 正是因为枚举类型要用在集合中，所有没有理由用位域来表示它，使用 EnumSet.of() 来表示枚举集合

37. 用 EnumMap 代替序数索引
    - 最好不要用序数来索引数组，而要使用 EnumMap

38. 用接口模拟可扩展的枚举
    - 虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型来对它进行模拟

39. 注解优先于命名模式（@Test > xxxTest）
    - 命名模式无法保证拼写正确，无法确保只应用于相应的程序元素上，且没有提供将参数值与程序执行元素关联起来的好方法
    - 既然有了注解，就完全没有理由再使用命名模式了
    - 所有的程序员都应该使用 Java 平台所提供的预定义的注解类型

40. 坚持使用 Override 注解
    - 在你想要覆盖超类声明的每个方法声明中使用 Override 注解

41. 用标记接口定义类型
    1. 标记接口定义的类型是由被标记类的实例实现的，标记注解则没有定义这样的类型
    2. 标记接口胜过标记注解的另一个优点是，它们可以被更加精确地进行锁定
    3. 标记注解胜过标记接口的最大优点在于，它们是最大的注解机制的一部分
    4. 当你正在编写 @Target 为 ElementType.TYPE 的标记注解类型，就要花点时间考虑清楚，它是否真的应该为注解类型，想想标记接口是否更加合适

## 7. Lambda 和 Stream

42. Lambda 优先于匿名类
    1. 删除所有 Lambda 参数的类型吧，除非它们的存在能够使程序变得更加清晰
    2. Lambda 没有名称和文档；如果一个计算本身不是自描述的，或者超出了几行，那就不要吧它放在一个 Lambda 中
    3. 尽可能不要序列化一个 Lambda（除非迫不得已）
    4. 千万不要给函数对象使用匿名类，除非必须创建非函数接口的类型的实例

43. 方法引用优先于 Lambda
    1. 只要方法引用更加简洁、清晰，就用方法引用；如果方法引用不够简洁，就坚持使用 Lambda

44. 坚持使用标准的函数接口
    1. 只要标准的函数接口能够满足需求（java.util.function），通常应该优先考虑，而不是专门再构建一个新的函数接口
    2. 千万不要用带包装类型的基础函数接口来代替基本函数接口（使用装箱类型进行批量操作处理，最终会导致致命的性能问题）
    3. 必须始终用 @FunctionalInterface 注解对自己编写的函数接口进行标注

45. 谨慎使用 Stream
    1. 一个 Stream pipeline 中包含一个源 Stream，接着是 0 个或多个中间操作和一个终止操作，每个中间操作都会通过某种方式对 Stream 进行转换
    2. 滥用 Stream 会使程序代码更难以读懂和维护
    3. 在没有显式类型的情况下，仔细命名 Lambda 参数，这对于 Stream pipeline 的可读性至关重要
    4. 在 Stream pipeline 中使用 helper 方法，对于可读性而言，比在迭代代码中使用更为重要
    5. 最好避免使用 Stream 来处理 char 值
    6. 重构现有代码来使用 Stream，并且只有在必要的时候才在新代码中使用
    7. 如果实在不确定用 Stream 还是用迭代比较好，那么两种都试试，看看哪一种更好用吧

46. 优先选择 Stream 中无副作用的函数
    1. Stream 泛型最重要的部分是把计算构造成一系列变型，每一级结构都尽可能靠近上一级结果的纯函数
    2. forEach 操作应该只用于报告 Stream 计算的结果，而不是执行计算
    3. 静态导入 Collectors 的所有成员是惯例也是明智的，因为这样可以提升 Stream pipeline 的可读性
    4. 没有必要使用 collect(counting())，直接使用 count() 方法即可

47. Stream 要优先于用 Collection 作为返回类型
    1. 对于公共的、返回序列的方法，Collection 或者恰当的子类型通常是最佳的返回类型
    2. 千万别在内存中保存巨大的序列，将它作为集合返回即可

48. 谨慎使用 Stream 并行
    1. 如果源头是来自 Stream.iterate，或者使用了中间操作的 limit，那么并行 pipeline 也不可能提升性能
    2. 千万不要任意地并行 Stream pipeline
    3. 在 Stream 上通过并行获得的性能，最好是通过 ArrayList、HashMap、HashSet 和 ConcurrentHashmap 实例，数组，int 范围和 long 范围等
    4. 并行 Stream 不仅可能降低性能，保活活性失败，还可能导致结果出错，以及难以预计的行为
    5. 只有在适当的情况下，给 Stream pipeline 添加 parallel 调用，才可以在多核处理器的情况下达到线性的倍增

## 8. 方法

49. 检查参数的有效性
    1. 在 Java7 中增加的 Objects.requireNotNull 方法比较灵活且方便，因此不必再手工进行 null 检查

50. 必要时进行保护性拷贝
    1. 假设类的客户端会尽其所能来破坏这个类的约束条件，因此你必须保护性地设计程序
    2. Date 已经过时了，不应该在新代码中使用（使用 java.time.LocalDate 代替）
    3. 对于构造器的每个可变参数进行保护性拷贝是必要的
    4. 保护性拷贝是在检查参数的有效性之前进行的，并且有效性检查是针对拷贝之后的对象，而不是针对原始的对象
    5. 对于参数类型可以被不可信任方子类化的参数，请不要使用 clone 方法进行保护性拷贝

51. 谨慎设计方法签名
    1. 谨慎地选择方法的名称
    2. 不要过于追求提供便利的方法（每个方法都应该尽其所能，方法太多会使类难以学习）
    3. 如果不能确定，最好不要提供快捷方式
    4. 避免过长的参数列表
    5. 相同类型的长参数序列格外有害
    6. 对于参数类型，要优先使用接口而不是类
    7. 对于 boolean 参数，要优先使用两个元素的枚举类型（代码更易于阅读和编写）

52. 慎用重载
    1. 要调用哪个重载方法是在编译时做出决定的
    2. 对于重载方法的选择是静态的，而对于被覆盖的方法的选择是动态的
    3. 应该避免胡乱地使用重载机制
    4. 安全而保守的策略说，永远不要导出两个具有相同参数数目的重载方法
    5. 始终可以给方法起不同的名称，而不使用重载机制
    6. 不要在相同的参数位置调用带有不同函数接口的方法

53. 慎用可变参数
    1. 可变参数每次调用时都会导致一次数组分配和初始化
    2. 在使用可变参数之前，要先包含所有必要的参数

54. 返回零长度的数组或集合，而不是 null
    1. 永远不要返回 null，而是返回一个零长度的数组或者集合（返回 null 会使 API 更难以使用和出错，而且没有任何性能优势）

55. 谨慎返回 Optional
    1. optional 本质上与受检异常相类似
    2. 容器类型（集合、映射、Stream）、数组和 optional，都不应该被包装在 optional 中
    3. 如果无法返回结果并且当没有返回结果时客户端必须执行特殊的处理，那么就应该声明该方法返回 Optional<T>
    4. 永远不应该返回基本包装类型的 optional（使用 OptionalInt, OptionalLong, OptionalDouble）
    5. 几乎永远都不适合用 optional 作为键、值、或者集合或数组中的元素

56. 为所有导出的 API 元素编写文档注释
    1. 要想使一个 API 真正可用，就必须为其编写文档
    2. 为了正确地编写 API 文档，必须在每个被导出的类、接口、构造器、方法和域声明之前增加一个文档注释
    3. 方法的文档注释应该简洁地描述出它和客户端之间的约定（应该说明它做了什么，而不是如何做的；参数的前提条件、后置条件；方法的副作用）
    4. 文档注释在源代码和产生的文档中都应该是易于阅读的
    5. 同一个类或者接口中的两个成员或者构造器，不应该具有同样的概要描述
    6. 当为泛型或方法编写文档时，确保要在文档中说明所有的类型参数
    7. 当为枚举类型编写文档时，要确保在文档中说明常量、类型以及所有公有的方法
    8. 为注解类型编写文档时，要确保在文档中说明所有成员
    9. 类或静态方法是否是线程安全，应该在文档中对它的线程安全级别进行说明
    10. 阅读由 Javadoc 工具生成的网页

## 通用编程

57. 将局部变量的作用域最小化
    1. 要使局部变量的作用域最小化，最有力的方法就是在第一次要使用它的地方进行声明
    2. 几乎每个局部变量的声明都应该包含一个初始化表达式
    3. for 循环优先于 while 循环

58. for-each 循环优先于传统的 for 循环
    1. 有 3 种情况无法使用 for-each 循环：
        1. 解构过滤：遍历集合以删除选定的元素时，需要使用显式的迭代器以便可以调用它的 remove 方法
        2. 转换：遍历列表或者数组，并取代它的部分或全部元素值，就需要列表迭代器或数组索引
        3. 平行迭代

59. 了解和使用类库
    1. 通过使用标准类库，可以充分利用这些编写标准类库的专家的知识，以及在你之前的其他人的使用经验
    2. 选择随机数生成器时，大多使用 ThreadLocalRandom，它会产生更高质量的随机数
    3. 在每个重要的发行版中，都会许多新的特性被加入到类库中，所以与这些特性保持同步是值得的
    4. 每个程序员都应该熟悉 java.lang、java.util、java.io 及其子包中的内容

60. 如果需要精确的答案，请避免使用 float 和 double
    1. float 和 double 类型尤其不适合用于货币计算
    2. 使用 BigDecimal、int 或者 long 进行货币计算

61. 基本类型优先于装箱基本类型
    1. 对装箱基本类型运用 == 操作符几乎总是错误的
    2. 当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱
    3. 自动装箱减少了使用装箱基本类型的繁琐性，但是并没有减少它的风险
    4. 当程序进行拆箱时，会抛出 NullPointerException 异常

62. 如果其他类型更适合，则尽量避免使用字符串
    1. 字符串不适合代替其他的值类型
    2. 字符串不适合代替枚举类型
    3. 字符串不适合代替聚合类型
    4. 字符串也不适合代替能力表/权限表

63. 了解字符串连接的性能
    1. 为连接 n 个字符串而重复地使用字符串连接操作符，需要 n 的平方级的时间
    2. 为了获得可以接受的性能，请用 StringBuilder 代替 String
    3. 不要使用字符串连接操作符来合并多个字符串

64. 通过接口引用对象
    1. 如果有合适的接口类型存在，那么对于参数、返回值、变量和域来说，都应该使用接口类型进行声明
    2. 如果没有合适的接口存在，完全可以使用类而不是接口来引用对象
    3. 如果没有适合的接口，就用类层次结构中提供了必要功能的最小的具体类来引用对象

65. 接口优先于反射机制
    1. 反射机制要付出的代价：损失了编译时检查的优势、执行反射所需要的代码笨拙而冗长、性能损失
    2. 如果只是以非常有限的兴衰使用反射机制，虽然也要付出少许代价，但是可以获得许多好处
    3. 用反射方式创建实例，然后通过它们的接口或超类，以正常的方式访问这些实例

66. 谨慎地使用本地方法
    1. 使用本地方法来提高性能的做法不值得提倡（JVM 变得越来越快了）

67. 谨慎地进行优化
    1. 要努力编写好的程序而不是快的程序
    2. 要努力避免那些限制性能的设计决策（模块间交互关系、模块与外部交互关系，最主要的是 API、交互层协议以及永久数据格式）
    3. 要考虑 API 设计决策的性能后果（API 设计对于性能的影响是非常实际的）
        1. 使公有的类型成为可变的，可能会导致大量不必要的保护性拷贝
        2. 在适合使用复合模式的公有类中使用继承，会把这个类与它的超类永远地束缚在一起
        3. 在 API 中使用实现类型而不是接口，会把你束缚在一个具体的实现上，将来无法使用更新的实现
    4. 为获得好的性能而对 API 进行包装，这是一种非常不好的想法
    5. 在每次试图做优化之前和之后，要对性能进行测量

68. 遵守普遍接受的命名惯例
    1. 命名惯例分为两大类：字面的、语法的
    2. 包和模块的名称应该是层次状的，用句号（.）分隔每个部分，每个部分包括小写字母，极少数情况下还有数字
    3. 包名称的其他部分应该包括一个或多个描述该包的组成部分
    4. 语法命名惯例比字面惯例更加灵活，也更有争议
        1. 可被实例的类通常用一个名词或短语命名，不可实例化的工具类经常用负数名词命名
        2. 执行某个动作的方法通常用动词或动词短语来命名
        3. 返回 boolean 值的方法往往以单词 is 开头，很少用 has
        4. 如果方法返回被调用对象的一个非 boolean 的函数或属性，通常用名词、名词短语、或以 get 开头的动词短语来命名（size、hashCode、getTime）
        5. 转换对象类型的实例方法，经常使用 toType 命名

## 10. 异常

69. 只针对异常的情况才使用异常
    1. 异常应该只用于异常的情况下，它们永远不应该用于正常的控制流
    2. 设计良好的 API 不应该强迫它的客户端为了正常的控制流而使用异常

70. 对可恢复的情况使用受检异常，对编程错误使用运行时异常
    1. Java 提供了三种可抛出结构（throwable）：受检异常（checked exception）、运行时异常（runtime exception）和错误（error）
    2. 如果期望调用者能够适当地恢复，对于这种情况应该使用受检异常（Exception 的子类，强迫调用者在 catch 子句中处理该异常）
    3. 有2种未受检的可抛出结构：未受检的异常和错误（未受检的异常也即 RuntimeException 的子类）
    4. 未受检往往就属于不可恢复的情形，不应该继续执行下去
    5. 用运行时异常来表明编程错误（如果情况允许恢复，就使用受检异常，否则使用运行时异常（RuntimeException 的子类））
    6. 错误（error）往往被 JVM 保留使用，你实现的所有未受检的抛出结构都应该是 RuntimeException 的子类

71. 避免不必要地使用受检异常
    1. 在谨慎使用的前提下，受检异常可以提升程序的可读性；如果过度使用，会造成 API 使用起来非常痛苦

72. 优先使用标准的异常
    1. 专家程序员与缺乏经验程序员的一个最主要的区别是：专家追求并且往往能实现代码的高度复用
    2. 使用标准的异常可使API 更易于学习和使用、可读性更好
    3. 最精彩被重用的异常类型有：IllegalArgumentException, IllegalStateException, NullPointerException, IndexOutOfBoundsException,
       UnsupportedOperationException
    4. 不要直接重用 Exception, RuntimeException, Throwable, Error，对待这些类要像对待抽象类易于
    5. 如果没有可用的参数值，就抛出 IllegalStateException，否则抛出 IllegalArgumentException

73. 抛出与抽象对应的异常
    1. 更高层的实现应该捕获底层的异常，同时抛出可用按照高层抽象进行解释的异常（即 异常转译）
    2. 尽管异常转译与不加选择地从底层传递异常的做法相比有所改进，但是也不能滥用它（更好的做法是提前拦截检查，从而尽可能的让低层代码执行成功）

74. 每个方法抛出的所有异常都要建立文档
    1. 始终要单独地声明受检异常，准确地记录下抛出每个异常的条件
    2. 如果公有方法可能抛出多个异常类，不要使用"快捷方式"声明抛出超类
    3. 使用 @throws 标签记录一个方法可能抛出的每个未受检异常，但是不要使用 throws 关键字将未受检异常包含在方法的声明中
    4. 如果一个类中的许多方法出于同样的原因而抛出同一个异常，在该类的文档注释中对这个异常建立文档，这是可以接收的

75. 在细节消息中包含失败-捕获信息
    1. 为了捕获失败，异常的细节信息应该包含"对异常有贡献"的所有参数和域的值
    2. 千万不要在细节信息中包含密码、密钥以及类似的信息

76. 努力使失败保持原子性
    1. 一般而言，失败的方法调用应该使对象保持在被调用之前的状态

77. 不要忽略异常
    1. 空 catch 块会使异常达不到应有的目的
    2. 如果选择忽略异常，catch 块中应该包含一条注释，说明为什么这么做，并且 exception 变量应该命名为 ignored

## 11. 并发

78. 同步访问共享的可变数据
    1. 为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的（如果没有同步，一个线程的变化就不能被其他线程看到）
    2. 千万不要使用 Thread.stop 方法，它本质上是不安全的，可能导致数据遭到破坏
    3. 除非读和写都被同步，否则无法保证同步其作用
    4. 将可变数据限制在单个线程中
    5. 当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步

79. 避免过度同步
    1. 在一个被同步的区域内部，不要调用设计成要被覆盖的方法，或者是由客户端以函数对象的形式提供的方法（意味着你将失去对客户端的控制）
    2. 通常来说，应该在同步区域内做尽可能少的工作（获得锁，检查共享数据，根据需要转换数据，然后释放锁，应设法将耗时动作移动到同步区域之外）

80. executor, task 和 stream 优先于线程（Thread）
    1. ExecutorService exec = Executors.newSingleThreadExecutor(); exec.execute(runnable); exec.shutdown();
    2. 不要编写自己的工作队列，尽量不直接使用线程

81. 并发工具优先于 wait 和 notify
    1. 正确地使用 wait 和 notify 比较困难，应该用更高级的并发工具来代替
    2. 并发集合中不可能排除并发活动，将它锁定没有什么作用，之后使程序的速度变慢
    3. 应该优先使用 ConcurrentHashMap，而不是使用 Collections.synchronizedMap
    4. 对于间歇式的定时，始终应该优先使用 System.nanoTime（更精确不受系统时钟所影响），而不是使用 System.currentTimeMillis
    5. 应该优先使用 notifyAll，而不是使用 notify 方法（请小心确保程序的活性）

82. 线程安全性的文档化
    1. 注意在方法声明中出现的 synchronized 修饰符并不是导出的 API 的一部分
    2. 一个类为了可被多个线程安全地使用，必须在文档中清楚地说明它所支持的线程安全级别（不可变的、无条件的线程安全、有条件的线程安全、非线程安全、线程对立的）
    3. 不可变域应始终声明为 final 的

83. 慎用延迟初始化
    1. 在大多数情况下，正常的初始化要优先于延迟初始化
    2. 如果利用延迟优化来破坏初始化的循环，就要使用同步访问方法
    3. 如果出于性能的考虑而需要对静态区域使用延迟初始化，就使用 lazy initialization holder class 模式（静态私有类+静态final域+初始化函数+getter公有方法）
    4. 如果出于性能的考虑而需要对实例域使用延迟初始化，就使用双重检查模式

84. 不要依赖于线程调度器
    1. 任何依赖于线程调度器来达到正确性或性能要求的程序，很有可能都是不可移植的
    2. 如果线程没有在做有意义的工作，就不应该运行
    3. 不要企图通过调用 Thread.yield 来"修正"该程序，Thread.yield 没有可测试的语义，更好的方法是重新构造程序
    4. 线程优先级是 Java 平台上最不可移植的特征了

## 12. 序列化

85. 其他方法优先于 Java 序列化


