# Effective Java

Java 支持 4 种类型：接口、类（包括 enum）、数组和基本类型。

把焦点放在 API 设计上，对于重构过程是多么有益。重构的基本目标是改进系统结构，以避免代码重复。  
如果系统的组件没有设计良好的 API，要达到这样的目标则是不可能的。

清晰性和简洁性最为重要：组件的用户永远也不应该被其行为所迷惑。  
代码应该被重用，而不是被拷贝。  
组件之间的依赖尽可能降到最小。  
错误应该尽早被检测出来。  
编写出清晰、正确、可用、健壮、灵活和可维护的程序。  

## 2.创建和销毁对象

1. 用静态工厂方法代替构造器
   - 优势
      1. 静态工厂方法它们有名称，可以更具语义
      2. 不必在每次调用它们的时候都创建一个新对象
      3. 它们可以返回原类型的任何子类型的对象
      4. 所返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值
      5. 方法返回对象所属的类，在编写包含该静态工厂方法时可以不存在（服务提供者框架）
   - 缺点
      1. 如果类不含公有的/受保护的构造器，就不能被子类化
      2. 程序员很难发现那些静态工厂方法
   - 静态工厂惯用名称
      1. from, of, valueOf, instance, getInstance, create, newInstance
      2. getType, newTYpe, type
2. 遇到多个构造器参数时考虑使用构建器（Builder）
   - 优势
      1. Builder 模式模拟了具名的可选参数，易于编写和阅读
      2. Builder 模式也适用于类层次结构
   - 缺点
      1. 为了创建对象，必须先创建它的构建器，可能有性能问题
3. 用私有构造器或枚举类型强化 Singleton 属性
   - 私有构造器 + 导出公有静态成员
   - 私有构造器 + 导出公有静态工厂方法（静态工厂方法的优势在于提供了灵活性）
   - 单元素的枚举类型
4. 通过私有构造器强化不可实例化的能力  
   - 企图通过将类做成抽象类来强制该类不可被实例化是行不通的
   - 让这个类包含一个私有构造器，它就不能被实例化（比如工具类就不希望被实例化，它只有静态方法和静态域）
5. 优先考虑依赖注入来引用资源
   - 静态工具类和 Singleton 类不适合与需要引用底层资源的类（资源可能有多种）
   - 当创建一个新的实例时，就将该资源传到构造器中
   - 可使用依赖注入框架（如 Spring）来解决手动注入的凌乱
6. 避免创建不必要的对象  
   - 自动装箱使得基本类型和装箱基本类型之间的差别变得模糊起来，但是并没有完全消失
   - 要优先使用基本类型而不是装箱基本类型，要当心无意识的自动装箱
   - 通过维护自己的对象池来避免创建对象并不是一种好的做法，除非对象池中的对象是非常重量级的
   - 因重用对象而付出的代价要远远大于因创建重复对象而付出的代价，前者会导致潜在的 Bug 和安全漏洞，后者只会影响程序风格和性能
7. 消除过期的对象引用
   - 无意识的对象保持，在支持垃圾回收语言中是很隐蔽的内存泄漏
   - 清空对象引用应该是一种例外，而不是一种规范行为
   - 只要类是自己管理内存，程序员就应该警惕内存泄漏问题
   - 内存泄漏的另一个场景来源是缓存
   - 内存泄漏的第三个常见来源是监听器和其他回调
   - 可借助 Heap Profiler 发现内存泄漏问题
8. 避免使用终结方法和清除方法
   - 终结方法（finalizer）通常是不可预测的，也是危险的，一般情况下是不必要的
   - 在 Java9 中庸清除方法（cleaner）代替了 finalizer，清除方法没有终结方法那么危险，但仍然是不可预测、运行缓慢，一般情况下也是不必要的
   - 终结方法和清除方法的缺点在于不能保证会被及时执行，Java规范根本不保证它们会被执行
   - 注重时间的任务不应该由终结方法或者清除方法来完成
   - 永远不应该依赖终结方法或清除方法来更新重要的持久状态
   - 使用终结方法和清除方法有一个非常严重的性能损失
   - 为了防止非 final 类受到终结方法攻击，要编写一个空的 final 的 finalize 方法
   - 终结方法和清除方法的好处有：1.当资源所有者忘记调用它的 close 方法时，终结方法或清除方法可充当"安全网"；2.与对象的本地对等体（native peer）有关，可用来清除非关键的本地方法所拥有的资源
9. try-with-resources 优先于 try-finally
   - try-with-resources 更简洁易懂，也更容易诊断

## 3.对于所有对象都通用的方法    

10. 覆盖 equals 时请遵循通用约定
   - 自反性：x.equals(x) == true，对称性：x.equals(y) == y.equals(x)，传递性，
   - 使用 == 检查参数是否为这个对象的引用；使用 instanceof 检查参数是否为正确的类型；把参数转换为正确的类型；对于该类中的每个关键域检查是否相匹配
   - 覆盖 equals 时总是要覆盖 hashCode；不要企图让 equals 方法过于智能；不要将 equals 声明中的 Object 对象替换为为他类型
11. 覆盖 equals 时总是要覆盖 hashCode
   - 相等的对象必须具有相等的散列码（hash code）
   - 不要试图从散列码计算中排除掉一个对象的关键域来提高性能
   - 不要对 hashCode 方法的返回值做出具体的规定，因此客户端无法理所当然的依赖它；这样可以为修改提供灵活性
12. 始终要覆盖 toString
   - 提供好的 toString 实现可以让类使用起来更加舒适、更易于调试
   - toString 方法应该返回对象中包含的所有值得关注的信息
   - 无论是否决定指定格式，都应该在文档中明确地表明你的意图
   - 为 toString 返回值中包含的信息提供一种可通过编程访问的途径（getter）
13. 谨慎地覆盖 clone
   - 实现 Cloneable 接口的类是为了提供一个功能适当的公有 clone 方法
   - 不可变的类永远都不应该提供 clone 方法
   - clone 方法就是另一个构造器；必须确保它不会伤害到原始的对象，并确保正确地创建被克隆对象中的约束条件
   - Cloneable 架构与引用可变对象的 final 域的正常用法是不相兼容的
   - 公有的 clone 方法应该省略 throws 声明（不抛出受检查一次的方法使用起来更轻松）
   - 对象拷贝的更好的办法是提供一个拷贝构造器或拷贝工厂
14. 考虑实现 Comparable 接口
   - Java 平台类库中的所有值类型和枚举类型都实现了 Comparable 接口
   - Comparable 接口也需要遵守等同性、自反性、对称性和传递性
   - Comparator<T> 可配置一组比较器构造方法，使得比较器的构造工作变得非常流畅
   - 避免使用 Comparator.compare() 方法，可能会造成整数溢出，可使用一个静态的 compare() 方法货真使用一个比较器的构造方法

## 4.类和接口

15. 使类和成员的可访问性最小化
    - 尽可能地使每个类或成员不被外界访问
    - private / package-private / protected / public
    - 公有类的实例域绝不能是公有的，包含公有可变域的类通常并不是线程安全的
    - 让类具有公有的静态 final 数组域，或者提供这种域的访问方法，这是错误的，因为客户端能够改变数组的内容，造成安全漏洞
16. 要在公有类而非公有域（静态域）中使用访问方法
    - 如果类可以在它所在的包之外进行访问，就提供访问方法
    - 如果类是包级私有的，或者是私有的嵌套类，直接暴露它的数据域并没有本质的错误
17. 使可变性最小化
    - 不可变对象比较简单
    - 不可变对象本质上是线程安全的，它们不要求同步，可以被自由地共享
    - 不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象
    - 如果类不能被做成不可变的，仍然应该尽可能地限制它的可变性
    - 构造器应该创建完全初始化的对象，并建立起所有的约束条件
18. 组合优先于继承
    - 与方法调用不同的是，继承打破了封装性
    - 只有子类和超类确实存在子类型关系时，且它们处在相同的包中，使用继承才是恰当的
19. 要么设计继承并提供文档说明，要么禁止继承
    - 该类必须有文档必须精确地描述覆盖每个方法所带来的影响
    - 类必须以精心挑选的受保护的（protected）方法的形式，提供恰当的钩子（hook），以便进入其内部工作
    - 对于为了继承而设计的类，唯一的测试方法就是编写子类，必须在发布之前编写子类对其进行测试
    - 为了允许继承，构造器决不能调用可被覆盖的方法（初始化子类时超类构造器中会调用到子类的覆盖方法，该方法可能依赖子类的构造器的初始化，可能出现非预期的状态）
    - 无论是 clone 和 readObject，都不可用调用可覆盖的方法，不管是以直接或间接的方式（clone/readObject 在行为上类似构造器）
    - 为了继承而设计的类，会有一些实质性的限制
    - 对于那些并非为了安全地进行子类化而设计和编写文档的类，要禁止子类化
20. 接口由于抽象类
    - 现有的类可以很容易被更新，以实现新的接口
    - 接口是定义混合类型（mixin）的理想选择
    - 接口允许构造非层次结构的类型框架
    - 接口使得安全地增强类的功能称为可能
    - 对于骨架实现类而言，好的文档绝对是非常必要的

21. 为后代设计接口
    - 有了缺省方法，接口的现有实现不会出现编译时没有报错或警告却在运行时失败的情况
    - 谨慎设计接口仍然是至关重要的
    - 或许接口程序发布之后也能纠正，但是千万别指望它！
    
22. 接口只用于定义类型
    - 常量接口模式是对接口的不良使用
    - 导出常量可考虑合理的类（如 Integer.MIN_VALUE）和枚举类型
    
23. 类层次优于标签类
    - 标签类（如包含枚举类型来区别类类型）过于冗长、容易出错，并且效率低下
    - 标签类正是对类层次的一种简单的仿效
    - 标签类很少有适用场景，应转换到类层次结构中去
    
24. 静态成员类优于非静态成员类
    - 如果声明成员类不要求访问外围实例，就要始终把修饰符 static 放在它的声明中

25. 限制源文件为单个顶级类
    - 永远不要把多个顶级类或接口定义在一个源文件中

## 5.泛型

26. 请不要使用原生态类型
    - 原生态类型是指泛型中未声明泛型参数
    - 如果使用原生态类型，就失去了泛型在安全性和描述性方面的所有优势
    - 如果使用像 List 这样的原生态类型，就会失去类型安全性，但是如果使用像 List<Object> 则不会
    - 不能将任何元素（除 null 之外）放到 Collection<?> 中，否则会编译出错类型不匹配
    
27. 消除非受检的警告（unchecking warning）
    - 要尽可能地消除每一个非受检警告
    - 如果无法消除警告，同时可以证明引起警告的代码是类型安全的，此时可以用 @SuppressWarnings("unchecked") 注解来禁止这条警告
    - 应该始终在尽可能小的范围内使用 SuppressWarnings 警告
    
28. 列表由于数组
    - 数组提供了运行时的类型安全，但是没有编译时的类型安全
    
29. 优先考虑泛型
    - 你不能创建不可具体化的类型的数组，如 <T> new T[]，但可以先创建 new Object[] 然后再进行数组类型转换，隐含前提是你需要保证类型安全并消除警告
    
30. 优先考虑泛型方法

31. 利用有限制通配符来提升 API 的灵活性
    - 为了获得最大限度的灵活性，要在表示生产者或消费者的输入参数上使用通配符类型
    - 如果某个输入参数既是生产者，又是消费者，那么通配符就没有好处了：因为你需要的是严格的类型匹配
    - PECS: producer-extends, consumer-super
    - 不要用通配符类型作为返回类型
    - 如果类的用户必须考虑通配符类型，类的 API 或许就会出错
    - 使用时始终应该是 Comparable<? super T> 优先于 Comparable<T>，Comparator<? super T> 同理
    - 如果类型参数只在方法声明中出现一次，就可以用通配符取代它

32. 谨慎同时使用泛型+可变参数
    - 将值保存在泛型可变参数数组中是不安全的
    - SafeVarargs 注解是通过方法的设计者做出承诺，声明这是类型安全的
    - 允许另一个方法访问一个泛型可变参数是不安全的，可变参数在实际的参数存入之后没有修改
    - 对于每一个带有泛型可变参数或者参数化类型的方法，都要用 @SafeVarargs 进行注解
    
33. 优先考虑类型安全的异构容器
    - 异构的：不像普通的映射，容器的所有键都是不同类型的
    - 可以使用 Class 对象作为键，以这种方式使用的 Class 对象称作类型令牌

## 6. 枚举和注解

34. 用 enum 代替 int 常量
    - 为了将数据与枚举常量关联起来，得声明实例域，并编写一个带有数据并将数据保存在域中的构造器
    - 枚举中的 switch 语句适合于给外部的枚举类型增加特定于常量的行为
    - 每当需要一组固定数量，并且在编译时就知道其成员的时候，就应该使用枚举
    - 枚举类型中的常量集并不一定要始终保持不变

35. 用实例域代替枚举的序数
    - 永远不要根据枚举的序数导出与它关联的值，而是要保存在一个实例域中

36. 用 EnumSet 代替位域
    - 如果一个枚举类型的元素主要用在集合中，一般使用 int 枚举模式（1<<0,1<<1,1<<2,1<<3），通过 OR 运算符将几个常量合并到一个集合中去，称作位域
    - 正是因为枚举类型要用在集合中，所有没有理由用位域来表示它，使用 EnumSet.of() 来表示枚举集合

37. 用 EnumMap 代替序数索引
    - 最好不要用序数来索引数组，而要使用 EnumMap

38. 用接口模拟可扩展的枚举
    - 虽然无法编写可扩展的枚举类型，却可以通过编写接口以及实现该接口的基础枚举类型来对它进行模拟

39. 注解优先于命名模式（@Test > xxxTest）
    - 命名模式无法保证拼写正确，无法确保只应用于相应的程序元素上，且没有提供将参数值与程序执行元素关联起来的好方法
    - 既然有了注解，就完全没有理由再使用命名模式了
    - 所有的程序员都应该使用 Java 平台所提供的预定义的注解类型

40. 坚持使用 Override 注解
    - 在你想要覆盖超类声明的每个方法声明中使用 Override 注解











