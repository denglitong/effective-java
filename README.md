# Effective Java

Java 支持 4 种类型：接口、类（包括 enum）、数组和基本类型。

把焦点放在 API 设计上，对于重构过程是多么有益。重构的基本目标是改进系统结构，以避免代码重复。  
如果系统的组件没有设计良好的 API，要达到这样的目标则是不可能的。

清晰性和简洁性最为重要：组件的用户永远也不应该被其行为所迷惑。  
代码应该被重用，而不是被拷贝。  
组件之间的依赖尽可能降到最小。  
错误应该尽早被检测出来。  
编写出清晰、正确、可用、健壮、灵活和可维护的程序。  

## 2.创建和销毁对象

1. 用静态工厂方法代替构造器
    - 优势
        1. 静态工厂方法它们有名称，可以更具语义
        2. 不必在每次调用它们的时候都创建一个新对象
        3. 它们可以返回原类型的任何子类型的对象
        4. 所返回的对象的类可以随着每次调用而发生变化，取决于静态工厂方法的参数值
        5. 方法返回对象所属的类，在编写包含该静态工厂方法时可以不存在（服务提供者框架）
    - 缺点
        1. 如果类不含公有的/受保护的构造器，就不能被子类化
        2. 程序员很难发现那些静态工厂方法
    - 静态工厂惯用名称
        1. from, of, valueOf, instance, getInstance, create, newInstance
        2. getType, newTYpe, type
2. 遇到多个构造器参数时考虑使用构建器（Builder）
    - 优势
        1. Builder 模式模拟了具名的可选参数，易于编写和阅读
        2. Builder 模式也适用于类层次结构
    - 缺点
        1. 为了创建对象，必须先创建它的构建器，可能有性能问题
3. 用私有构造器或枚举类型强化 Singleton 属性
    - 私有构造器 + 导出公有静态成员
    - 私有构造器 + 导出公有静态工厂方法（静态工厂方法的优势在于提供了灵活性）
    - 单元素的枚举类型
4. 通过私有构造器强化不可实例化的能力  
    - 企图通过将类做成抽象类来强制该类不可被实例化是行不通的
    - 让这个类包含一个私有构造器，它就不能被实例化（比如工具类就不希望被实例化，它只有静态方法和静态域）
5. 优先考虑依赖注入来引用资源
    - 静态工具类和 Singleton 类不适合与需要引用底层资源的类（资源可能有多种）
    - 当创建一个新的实例时，就将该资源传到构造器中
    - 可使用依赖注入框架（如 Spring）来解决手动注入的凌乱